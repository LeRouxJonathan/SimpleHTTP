<?php

class HTTPFile
{
	//The name of the HTML <input type = "file"> element that supplied this file
	public $input_name;
	
	//The user-given name of the file
	public $file_name;
	
	//The temporary name of the file applied by the server
	public $server_name;
	
	//The type of file
	public $type;
	
	//The size of the file
	public $size;
	
	//The extension of the file
	public $file_extension;
	
	//The valid extensions (.pdf, .txt), etc.
	public $valid_extensions;
	
	//Note: filevalue is the name and all array components of a normal "_FILES" object array
	function __construct($input_name)
	{
	  $this->input_name = $input_name;
	 
	  //Name and values array construction
	  if ( isset($_FILES[$this->input_name]) === TRUE )
	  {
	  	$this->file_name = strip_tags($_FILES[$this->input_name]["name"], ENT_QUOTES); //As of php 5.4 UTF-8 is default
	    $this->server_name = $_FILES[$this->input_name]["tmp_name"]; //As of php 5.4 UTF-8 is default
	    $this->type = $_FILES[$this->input_name]["type"];
		$this->size = $_FILES[$this->input_name]["size"];
		
		//Harvest the file extension
		
		//If the file has a period in it, it has an extension; otherwise, it's an invalid extension
		if(strpos($this->file_name, ".") !== FALSE)
		{
		  $file_pieces = explode(".", $this->file_name);
	      $extension = $file_pieces[count($file_pieces) - 1];
		  
		  //Edge-case: User file is of format: name.txt. (with a trailing period)
		  if (trim($extension) !== "" && $extension !== NULL && empty($extension) === FALSE)
		  {
		    $this->file_extension = $extension;
		  }
		  else 
		  {
		    $this->file_extension = NULL; 
		  }
		}
		else
		{
		  $this->file_extension = NULL;
		}
		
	  }
		 
	  else 
	  {
	  	$this->file_name  = NULL;
	    $this->server_name = NULL;
		$this->type = NULL;
		$this->size = NULL;
		$this->file_extension = NULL;
		$this->valid_extensions = NULL;
	  }	

	}//End: __construct()
	
	
	//Returns the necessary portions of the file in order to attach a file to a PHPMAILER e-mail
	function getAsAttachment()
	{
	  return array($this->getServerName(), $this->getFileName());
	}//end: getAsAttachment()
	
	//Returns the name of the <input> or querystring associated with this file
	function getInputName()
	{
	  return $this->input_name;
	}//end: getInputName()
	
	//Returns the name of the file
	function getFileName()
	{
	  return $this->file_name;
	}//end: getFileName()
	
	//Returns the temporary name for the file generated by the server
	function getServerName()
	{
	  return $this->server_name;
	}//end: getServerName()
	
	
	//Returns the type of the File
	function getType()
	{
	  return $this->type;
	}//end: getType()
	
	//Returns, in bytes, the size of the file
	function getSize()
	{
	  return $this->size;
	}//end: getSize()
	

	
	
	
	//Returns the given file extension based off of the user's file's given name
	function getFileExtension()
	{
	  return $this->file_extension;
	}//end: getFileExtension()
	
	
	//Set the file extensions to be allowed by this file input
	function setValidExtensions($valid_extensions)
	{
	  for ($i = 0; $i < count($valid_extensions); $i++)
	  {
	    $element = $valid_extensions[$i];
		  
		if (strpos($element, ".") !== FALSE)
		{
		  $pieces = explode(".", $element);
			 
		  //Set the element's new value: The same value, but without the "." prefix before the extension
		  $valid_extensions[$i] = $pieces[count($pieces) - 1];
		}
	  }
	
      $this->valid_extensions = $valid_extensions;		
	}//end: setValidExtensions()
	
	//Returns the allowed file extensions
	function getValidExtensions()
	{
	  return $this->valid_extensions;
	}//end: getValidExtensions()
	
	
	
	//Checks if given file is of a valid extension type
	function isValidExtension()
	{
	  $is_valid_extension = FALSE;	

	  //Get the allowed extensions that have been set as valid for this file
	  $valid_extensions = $this->getValidExtensions();
	  
	  
	  //If we have valid extensions set, analyze to see if the extension is a match
	  if ($valid_extensions !== NULL && count($valid_extensions) > 0)
	  {
	    $extension = $this->getFileExtension();
		
	    //If the file extension for this given user file is set as valid, return TRUE;
	    for ($i = 0; $i < count($valid_extensions); $i++)
	    {
	      if ($extension === $valid_extensions[$i])
		  {
		    $is_valid_extension = TRUE; 
		  }
        }  
	  }
	  
	  //If we don't have any valid extensions set, all extensions are valid
	  else 
	  {
	    $is_valid_extension = TRUE; 
	  }
	 	
	  return $is_valid_extension; 
	}//end: isValidExtension()
	
	
	//Checks to see if the file exists
	function exists()
	{
	  $file_exists = FALSE;
	  
	  if ($this->server_name !== NULL)
	  {
	    $file_exists =  TRUE;
	  }
	  else
	  {
	    $file_exists =  FALSE;
	  }
	  
	  return $file_exists;
	}//end: exists()
	
	
	//Determines the validity of file by ensuring extension validity and existance of the file
	function isValid()
	{
		
	  $is_valid = FALSE;
	  
	  if ($this->isValidExtension() === TRUE && $this->exists() === TRUE)
	  {
	    $is_valid = TRUE;
	  }
	  else
	  {
	    $is_valid = FALSE;
	  }
	  
	  return $is_valid;
	}//end: isValid()
	
}//End: HTTPFile Class

class HTTPFileGroup
{
  public $requireds;
  
  
  //$requiredFileDataArray: (array) An array of strings listing our required <input> elements or querystring elements
  function __construct($required_files_array)
  {
    $this->requireds = $required_files_array;
  }
  
  
  //Determines the presence of all required files in the HTTPFileGroup
  function isValid()
  {
    $is_valid = FALSE;
	
	if (isset($this->requireds) === TRUE)
	{
	  $len = count($this->requireds);
	  for ($i = 0; $i < $len; $i++)
	  {
		$file = new HTTPFile($this->requireds[$i]);
		if ($file->isValid() === TRUE)
		{
          $is_valid = TRUE;
		}
	  }
    }
	
	else
	{
	  $is_valid = FALSE;
	}
	
    return $is_valid;
  }//end: isValid()
    
}///end: HTTPFileGroup
?>